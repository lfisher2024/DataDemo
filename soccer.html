<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Retro Soccer</title>
  <style>
    :root {
      --scale: 5;               /* visual upscaling for chunky pixels */
      --base-w: 160;            /* internal canvas width */
      --base-h: 120;            /* internal canvas height */
      --ui: #fefefe;
      --blue: #4ec0ff;
      --red: #ff5c5c;
      --grass1: #1a6f2b;
      --grass2: #168428;
      --line: #d8ffd8;
    }
    html, body {
      height: 100%;
      margin: 0;
      background: #0a0a0a;
      color: var(--ui);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
      display: grid;
      place-items: center;
    }

    .frame {
      display: grid;
      gap: 12px;
      place-items: center;
    }

    canvas {
      width: calc(var(--base-w) * var(--scale) * 1px);
      height: calc(var(--base-h) * var(--scale) * 1px);
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      background: #084a1b;
      border-radius: 12px;
      box-shadow:
        0 0 0 4px rgba(255,255,255,0.05) inset,
        0 20px 60px rgba(0,0,0,0.6),
        0 6px 16px rgba(0,0,0,0.6) inset;
      position: relative;
    }

    .hud {
      text-align: center;
      opacity: 0.9;
      font-weight: 600;
      letter-spacing: 0.5px;
      font-size: 14px;
    }

    .btns { display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; }
    .btns button {
      background: #161616;
      color: var(--ui);
      border: 1px solid #2c2c2c;
      padding: 8px 10px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
    }
    .btns button:active { transform: translateY(1px); }
  </style>
</head>
<body>
  <div class="frame">
    <canvas id="game" width="160" height="120" aria-label="Retro Soccer"></canvas>
    <div class="hud" id="hud">WASD/Arrows to move · Space to kick · Enter to start/pause</div>
    <div class="btns">
      <button id="startBtn">▶ Start / Pause (Enter)</button>
      <button id="resetBtn">↺ Reset</button>
    </div>
  </div>

  <script>
    // --- Helper math ---
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const dist2 = (x1,y1,x2,y2)=>{let dx=x2-x1, dy=y2-y1; return dx*dx+dy*dy;};

    // --- Canvas setup ---
    const cvs = document.getElementById('game');
    const ctx = cvs.getContext('2d');
    ctx.imageSmoothingEnabled = false;

    // --- Game state ---
    const W = cvs.width, H = cvs.height;
    const GOAL_TOP = 40, GOAL_BOT = 80; // y-range for scoring
    const CENTER = {x: W/2, y: H/2};

    let keys = {};
    let paused = true;
    let score = { you: 0, cpu: 0 };
    let timeLeft = 90; // seconds per match (retro quick match)
    let lastTime = 0;

    const player = { x: 30, y: CENTER.y, w: 6, h: 6, spd: 0.9, color: getCSS('--blue'), lastMove: {x: 1, y: 0} };
    const cpu    = { x: W-30, y: CENTER.y, w: 6, h: 6, spd: 0.85, color: getCSS('--red'),  lastMove: {x:-1, y: 0} };
    const gkL    = { x: 8,  y: CENTER.y, w: 6, h: 8, spd: 0.7,  color: '#b0d7ff' };
    const gkR    = { x: W-8, y: CENTER.y, w: 6, h: 8, spd: 0.7,  color: '#ffb0b0' };

    const ball = { x: CENTER.x, y: CENTER.y, r: 2, vx: 0, vy: 0 };

    function getCSS(varName){
      return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
    }

    // --- Input ---
    const down = e=>{ keys[e.key.toLowerCase()] = true; if(e.key===' ') e.preventDefault(); };
    const up   = e=>{ keys[e.key.toLowerCase()] = false; };
    window.addEventListener('keydown', down);
    window.addEventListener('keyup', up);
    document.getElementById('startBtn').onclick = togglePause;
    document.getElementById('resetBtn').onclick = resetMatch;

    function togglePause(){ paused = !paused; if(!paused) { lastTime = performance.now(); loop(lastTime); } draw(); }
    function resetMatch(){ score.you = 0; score.cpu = 0; timeLeft = 90; resetKickoff(Math.random()>0.5?'you':'cpu'); draw(); }

    function resetKickoff(who){
      ball.x = CENTER.x; ball.y = CENTER.y; ball.vx = 0; ball.vy = 0;
      player.x = 30; player.y = CENTER.y; cpu.x = W-30; cpu.y = CENTER.y;
      gkL.y = CENTER.y; gkR.y = CENTER.y;
      // Nudge ball towards the team that kicks off
      const dir = (who==='you') ? 1 : -1;
      ball.vx = 0.6 * dir; ball.vy = (Math.random()-0.5)*0.4;
    }

    // --- Game loop ---
    function loop(now){
      if (paused) return; // stop loop when paused
      const dt = Math.min(0.04, (now - lastTime) / 1000);
      lastTime = now;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    // --- Update ---
    function update(dt){
      // timer
      timeLeft = Math.max(0, timeLeft - dt);
      if(timeLeft === 0){ paused = true; }

      // player input (WASD + arrows)
      let mvx = 0, mvy = 0;
      if(keys['w'] || keys['arrowup']) mvy -= 1;
      if(keys['s'] || keys['arrowdown']) mvy += 1;
      if(keys['a'] || keys['arrowleft']) mvx -= 1;
      if(keys['d'] || keys['arrowright']) mvx += 1;
      if(mvx||mvy){
        const len = Math.hypot(mvx, mvy) || 1;
        player.x += (mvx/len) * player.spd * 60 * dt * 0.5;
        player.y += (mvy/len) * player.spd * 60 * dt * 0.5;
        player.lastMove = {x: mvx/len, y: mvy/len};
      }

      // clamp inside field
      for(const p of [player, cpu, gkL, gkR]){
        p.x = clamp(p.x, 6, W-6);
        p.y = clamp(p.y, 6, H-6);
      }

      // simple CPU logic: chase ball, but stay to right half
      const targetX = Math.max(W/2 + 8, ball.x + 6);
      const targetY = clamp(ball.y + (Math.random()-0.5)*6, 10, H-10);
      moveTowards(cpu, targetX, targetY, cpu.spd, dt);

      // goalkeepers track ball Y within goal mouth bounds
      moveTowards(gkL, gkL.x, clamp(ball.y, GOAL_TOP+6, GOAL_BOT-6), gkL.spd, dt);
      moveTowards(gkR, gkR.x, clamp(ball.y, GOAL_TOP+6, GOAL_BOT-6), gkR.spd, dt);

      // ball physics
      ball.x += ball.vx * 60 * dt;
      ball.y += ball.vy * 60 * dt;

      // friction
      ball.vx *= 0.99; ball.vy *= 0.99;
      if(Math.hypot(ball.vx, ball.vy) < 0.02){ ball.vx = 0; ball.vy = 0; }

      // wall bounce (except where goals are)
      if(ball.y - ball.r < 2 || ball.y + ball.r > H-2){ ball.vy *= -0.9; ball.y = clamp(ball.y, 2+ball.r, H-2-ball.r); }

      // goal detection
      if(ball.x - ball.r < 0){
        if(ball.y>GOAL_TOP && ball.y<GOAL_BOT){ score.cpu++; resetKickoff('cpu'); flash(); }
        else { ball.vx *= -0.9; ball.x = ball.r; }
      }
      if(ball.x + ball.r > W){
        if(ball.y>GOAL_TOP && ball.y<GOAL_BOT){ score.you++; resetKickoff('you'); flash(); }
        else { ball.vx *= -0.9; ball.x = W - ball.r; }
      }

      // collisions player/cpu/gk with ball
      for(const p of [player, cpu, gkL, gkR]){
        resolveBallPlayer(ball, p);
      }

      // kicking (space)
      if(keys[' ']){
        // player kick if close enough
        const d2 = dist2(player.x, player.y, ball.x, ball.y);
        if(d2 < 11*11){
          const aim = {
            x: ball.x - player.x + player.lastMove.x*3,
            y: ball.y - player.y + player.lastMove.y*3
          };
          const len = Math.hypot(aim.x, aim.y) || 1;
          const power = 2.8; // retro boost!
          ball.vx = (aim.x/len) * power;
          ball.vy = (aim.y/len) * power;
          screenShake(4);
        }
        // CPU occasional auto-kick
        const d2c = dist2(cpu.x, cpu.y, ball.x, ball.y);
        if(d2c < 11*11 && Math.random()<0.12){
          const aim = { x: -(ball.x - cpu.x) - 2, y: (Math.random()-0.5)*8 };
          const len = Math.hypot(aim.x, aim.y) || 1;
          ball.vx = (aim.x/len) * 2.6;
          ball.vy = (aim.y/len) * 2.6;
        }
      }
    }

    function moveTowards(obj, tx, ty, spd, dt){
      const dx = tx - obj.x, dy = ty - obj.y; const d = Math.hypot(dx, dy) || 1;
      obj.x += (dx/d) * spd * 60 * dt * 0.5; obj.y += (dy/d) * spd * 60 * dt * 0.5;
    }

    function resolveBallPlayer(b, p){
      // treat player as rectangle, do circle-rect collision
      const halfw = p.w/2, halfh = p.h/2;
      const cx = clamp(b.x, p.x - halfw, p.x + halfw);
      const cy = clamp(b.y, p.y - halfh, p.y + halfh);
      const dx = b.x - cx, dy = b.y - cy;
      const d2 = dx*dx + dy*dy;
      const r2 = b.r*b.r;
      if(d2 < r2){
        const d = Math.sqrt(d2) || 0.0001;
        const nx = dx/d, ny = dy/d;
        // push out
        b.x = cx + nx * (b.r + 0.01);
        b.y = cy + ny * (b.r + 0.01);
        // bounce
        const dot = b.vx*nx + b.vy*ny;
        b.vx -= 1.8*dot*nx; b.vy -= 1.8*dot*ny;
        // add some player momentum
        if(p===player) { b.vx += player.lastMove.x*0.4; b.vy += player.lastMove.y*0.4; }
      }
    }

    // --- Drawing ---
    let shake = 0;
    function screenShake(intensity){ shake = Math.max(shake, intensity); }
    function flash(){
      // small white flash by drawing a white rect with alpha once
      flashAlpha = 0.6;
    }
    let flashAlpha = 0;

    function draw(){
      // optional CRT-like shake
      const ox = (Math.random()-0.5) * (shake>0?2:0);
      const oy = (Math.random()-0.5) * (shake>0?2:0);
      if(shake>0) shake *= 0.9;

      ctx.save();
      ctx.translate(ox, oy);
      drawField();

      // goals (posts)
      ctx.fillStyle = getCSS('--line');
      // left and right goal lines
      rect(0, GOAL_TOP, 1, GOAL_BOT-GOAL_TOP);
      rect(W-1, GOAL_TOP, 1, GOAL_BOT-GOAL_TOP);

      // players
      drawPixelPlayer(player);
      drawPixelPlayer(cpu);
      drawKeeper(gkL);
      drawKeeper(gkR);

      // ball (classic black/white simplified)
      ctx.fillStyle = '#ffffff';
      circ(ball.x, ball.y, ball.r);
      ctx.fillStyle = '#00000055';
      circ(ball.x-0.5, ball.y-0.5, Math.max(0, ball.r-1));

      // center circle
      ctx.strokeStyle = getCSS('--line');
      ctx.lineWidth = 1;
      circLine(CENTER.x, CENTER.y, 12);

      // overlays
      drawScanlines();
      drawVignette();

      // HUD text
      ctx.fillStyle = '#ffffff';
      smallText(`${score.you} : ${score.cpu}`, W/2-6, 4);
      smallText(timeToStr(timeLeft), 4, 4);
      if(paused){
        banner(paused && timeLeft===0 ? (score.you>score.cpu? 'YOU WIN!' : score.you<score.cpu? 'CPU WINS' : 'DRAW') : 'PRESS ENTER');
      }

      if(flashAlpha>0){
        ctx.fillStyle = `rgba(255,255,255,${flashAlpha.toFixed(2)})`;
        ctx.fillRect(0,0,W,H);
        flashAlpha *= 0.85;
      }

      ctx.restore();
    }

    function drawField(){
      // grass stripes
      for(let y=0; y<H; y+=8){
        ctx.fillStyle = (y/8)%2===0 ? getCSS('--grass1') : getCSS('--grass2');
        rect(0, y, W, 8);
      }
      // boundary
      ctx.strokeStyle = getCSS('--line');
      ctx.lineWidth = 1;
      rectStroke(2, 2, W-4, H-4);
      // mid line & circle
      rect( (W/2)-0.5, 2, 1, H-4);
      // penalty boxes
      rectStroke(2, GOAL_TOP-8, 30, (GOAL_BOT-GOAL_TOP)+16);
      rectStroke(W-32, GOAL_TOP-8, 30, (GOAL_BOT-GOAL_TOP)+16);
    }

    function drawPixelPlayer(p){
      // simple 6x6 blocky sprite with two-tone
      const x = Math.round(p.x - p.w/2);
      const y = Math.round(p.y - p.h/2);
      ctx.fillStyle = '#00000055'; rect(x, y+1, p.w, p.h); // drop shadow
      ctx.fillStyle = p.color; rect(x, y, p.w, p.h-1);
      ctx.fillStyle = '#ffffff'; rect(x+2, y-1, 2, 2); // tiny head highlight
    }

    function drawKeeper(p){
      const x = Math.round(p.x - p.w/2);
      const y = Math.round(p.y - p.h/2);
      ctx.fillStyle = '#00000055'; rect(x, y+1, p.w, p.h);
      ctx.fillStyle = p.color; rect(x, y, p.w, p.h-1);
      ctx.fillStyle = '#fff'; rect(x+1, y-2, 4, 2);
    }

    function drawScanlines(){
      ctx.globalAlpha = 0.15;
      ctx.fillStyle = '#000';
      for(let y=0; y<H; y+=2){ rect(0, y, W, 1); }
      ctx.globalAlpha = 1;
    }

    function drawVignette(){
      const g = ctx.createRadialGradient(W/2, H/2, 10, W/2, H/2, Math.max(W,H)/1.2);
      g.addColorStop(0, 'rgba(0,0,0,0)');
      g.addColorStop(1, 'rgba(0,0,0,0.5)');
      ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
    }

    function banner(text){
      // center banner
      const w = text.length * 4 + 8;
      const x = (W - w)/2, y = H/2 - 8;
      ctx.fillStyle = 'rgba(0,0,0,0.6)'; rect(x-2,y-2,w+4,14);
      ctx.fillStyle = '#fff';
      smallText(text, x+4, y+2);
      smallText('Enter = start/pause, R = reset', x+4, y+8);
    }

    function smallText(s, x, y){
      // 4x6 pixel font (very tiny), drawn manually via canvas fillText fallback
      // We'll fake a crisp bitmap by scaling up context temporarily
      ctx.save();
      ctx.imageSmoothingEnabled = false;
      ctx.scale(1,1);
      ctx.font = '6px monospace';
      ctx.textBaseline = 'top';
      ctx.fillText(s, Math.round(x), Math.round(y));
      ctx.restore();
    }

    // tiny drawing helpers
    function rect(x,y,w,h){ ctx.fillRect(Math.floor(x), Math.floor(y), Math.ceil(w), Math.ceil(h)); }
    function rectStroke(x,y,w,h){ ctx.strokeRect(Math.floor(x)+0.5, Math.floor(y)+0.5, Math.floor(w)-1, Math.floor(h)-1); }
    function circ(x,y,r){ ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill(); }
    function circLine(x,y,r){ ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.stroke(); }

    // --- Controls: Enter to start/pause, R to reset ---
    window.addEventListener('keydown', (e)=>{
      if(e.key === 'Enter'){ togglePause(); }
      if(e.key.toLowerCase() === 'r'){ resetMatch(); }
    });

    // initial draw
    resetKickoff('you');
    draw();
  </script>
</body>
</html>
